<!DOCTYPE html>
<html>
  <head>
    <title>Data Masking in GraphQL Clients</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      /*! global/fonts */
      @font-face {
          font-family: Miller Display Light;
          src: url("https://a.1stdibscdn.com/dist/fonts/MillerDisplay/MillerDisplay-Light.woff") format("woff");
          font-weight: 400;
          font-style: normal
      }

      @font-face {
          font-family: Miller Display Light Italic;
          src: url("https://a.1stdibscdn.com/dist/fonts/MillerDisplay/MillerDisplay-LightItalic.woff") format("woff");
          font-weight: 400;
          font-style: normal
      }

      @font-face {
          font-family: Proxima Nova Light;
          src: url("https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-Light.woff") format("woff");
          font-weight: 400;
          font-style: normal
      }

      @font-face {
          font-family: Proxima Nova Light Italic;
          src: url("https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-LightItalic.woff") format("woff");
          font-weight: 400;
          font-style: normal
      }

      @font-face {
          font-family: Proxima Nova SemiBold;
          src: url("https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-Sbold.woff") format("woff");
          font-weight: 400;
          font-style: normal
      }

      body {
        font-family: 'Proxima Nova Light';
        color: #222;
      }
      h1, h2, h3 {
        font-family: 'Miller Display Light';
        font-weight: 400;
      }

      .remark-slide-content h1, h1 .remark-inline-code {
        font-size: 38px !important;        
      }

      .remark-slide-content h2 {
        font-size: 32px !important;        
      }

      .remark-slide-content h3 {
        font-size: 26px;        
      }

      .remark-slide-content li {
        font-size: 32px;   
        line-height: 1.6;     
      }

      .remark-code, .remark-inline-code {
        font-family: courier;
        font-size: 16px;
      }

      .flex {
        display: flex;
      }

      .big {
        margin: 0;
      }

      .bigCode .remark-code{
        font-size: 18px!important;
      }

      .column {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .addition {
        box-sizing: border-box;
        height: 100%;
      }
      .codeBorder {
        border: 1px solid #ddd;
        padding: 5px;
      }

      .codeBorder h3 {
        margin: 0!important;
      }

      .codeBorder pre {
        margin: 0;
      }

      .smallCode .remark-code {
        font-size:12px!important;
      }

      .column-arrow {
        font-size: 60px!important;
        flex: 1;
        text-align: center;
        vertical-align: middle;
        justify-content: center;
        align-items: center;
        display: flex;
      }

      .plus {
        font-size: 60px!important;
        font-weight: bold;
        flex: 1;
        text-align: center;
        vertical-align: middle;
        justify-content: center;
        display: flex;
        padding: 0px;
        margin: 12px;
      }
      .equals {
        font-size: 60px!important;
        font-weight: bold;
        flex: 1;
        text-align: center;
      }
      .columnPlus {
        margin-top: 67px;
      }
      .marginTop {
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Data Masking in GraphQL Clients

## Rob Richard
### GraphQL Europe 2018

---

# Data Masking in GraphQL Clients
* Data masking is a unique feature supported in Relay
* First a brief overview of the Relay API

---

# Relay API `<QueryRenderer/>`

```jsx
const MyComponent => (
  <QueryRenderer
    query={graphql`
      query MyComponentQuery($personId: ID!) {
        person(id: $personId) {
          id
          height
          homeworld {
            id
            name
          }
        }
      }
    `}
    variables={{personId: "xlOjM="}}
    render={({props}) => {
      if (!props) {
        return <div>Loading</div>;
      }
      return (
        <div>
          <h1>{props.person.name}</h1>
          <div>height: {props.person.height}</div>
          <div>home world: {props.person.homeworld.name}</div>
        </div>
      );
    }}
  />
);

```

???
* QueryRenderer is a React Component provided by Relay
* First prop is a GraphQL query
* Second prop is the variables for that query
* This component will execute this query against your GraphQL server
* It has a `render` prop, which is called twice, first to render the loading state, and again with the response from your GraphQL server.
* This example is using a QueryRenderer to fetch and render all the data it needs
* These examples are using the Star Wars GraphQL API.

---
# `createFragmentContainer`

```javascript
const PersonComponent = ({person}) => (
  <div>
    <h1>{person.name}</h1>
    <div>height: {person.height}</div>
    <div>homeworld: {person.homeworld.name}</div>
  </div>
)

export default createFragmentContainer(PersonComponent, {
  person: graphql`
    fragment PersonComponent_person on Person {
      id
      height
      homeworld {
        id
        name
      }
    }
  `
})
```

???
* `createFragmentContainer` creates a higher order component.
* These components are used as children of a QueryRenderer
* It provides a way to couple a GraphQL fragment to a component.
* This allows the component to define it's data depedency via the fragment 

---
# Updated `<QueryRenderer/>`

```diff
const MyComponent => (
  <QueryRenderer
    query={graphql`
      query MyComponentQuery($personId: ID!) {
        person(id: $personId) {
+          ...PersonComponent_person
        }
      }
    `}
    variables={{personId: "xlOjM="}}
    render={({props}) => {
      if (!props) {
        return <div>Loading</div>;
      }
+      return <PersonComponent person={props.person} />;
    }}
  />
);
```

???
* Now I've updated this QueryRenderer to use that fragment container.
* We reference this fragment in the `QueryRenderer`'s query
* We render this component in the `render` prop.
* We can also consume fragment containers from other fragment containers.

---
# Why use `createFragmentContainer`?
* Allows components to define their data requirements
* Components are reusable
* Data masking

???
* Why use `createFragmentContainer`?
* You could just write the whole query at the top of your app
* A fragment container allows components to define their data requirements
* * It's a declarative way to describe the data you need
* It also allows components to be more reusable
* * You can drop the component you need into other places of your app without adjusting your data fetching
* * All you need to use this component is a reference to a Person object.
* * If it's used in multiple places and you need more data, you only need to change this one file
* * Provides data masking

---
# What is data masking?

* Data masking prevents components from accessing data they did not specifically request

---
# Data masking example


```diff
const PersonComponent = ({person}) => {
+ console.log(person.homeworld.name); // undefined!
  return (
    <div>
      <h1>{person.name}</h1>
      <div>height: {person.height}</div>
+     <PlanetComponent planet={person.homeworld} />
    </div>
  );
}

export default createFragmentContainer(PersonComponent, {
  person: graphql`
    fragment PersonComponent_person on Person {
      id
      height
      homeworld {
+       ...PlanetComponent
      }
    }
  `
})

```
???
* I've created a new PlanetComponent and updated the PersonComponent to use it to render this person's homeworld.
* * The PlanetComponent will have it's own fragment and request whatever data it needs
* I have a console log in here to demostrate that the PersonComponent, even though it's a parent of the PlanetComponent, does not have access to the data requested by the PlanetComponent
* PersonComponent is decoupled from PlanetComponent. It only knows that it needs to pass a planet object to it as a prop.
* If PlanetComponent requirements change and it needs more planet data to render, no changes are required to the components that consume it.

---
# How is data masking implemented?

* There's a two step process to render GraphQL data
* Step 1 - The network response is "flattened" into a store
* Step 2 - Data to be rendered is "selected" out of the store

---

# The network response is "flattened" into a store

.flex[

.column.bigCode[
### GraphQL Response
```json
{
  "data": {
    "person": {
      "id": "xlOjM=",
      "height": 96,
      "name": "R2-D2",
      "homeworld": {
        "id": "V0czo4",
        "name": "Naboo"
      }
    }
  }
}
```
]

.column-arrow[
â†’
]

.column.bigCode[
### Client Store
```json
{
  "xlOjM=": {
    "height": 96,
    "name": "R2-D2",
    "homeworld": {
      "__ref": "V0czo4"
    }
  },
  "V0czo4": {
    "name": "Naboo"
  }
}
```
]

]

???
* Each object returned by the graphql server is put into a "flattened" object.
* The id returned by the graphql server is used as the key. If there were more objects in this response they would each be added as separate keys.
* Nested objects are referenced back into the store object by their ID by that __ref property

---
# Selecting data out of the store

* A selector can be created from both
* * The GraphQL fragment
* * A reference to the right object


---
# Selecting data out of the store

.big.flex[

.column[
.addition.codeBorder[
### Client Store
```json
{
  "xlOjM=": {
    "height": 96,
    "name": "R2-D2",
    "homeworld": {
      "__ref":
        "V0czo4"
    }
  },
  "V0czo4": {
    "name": "Naboo"
  }
}
```
]
]

.column[
.plus[+]
]


.column[
.addition.codeBorder[
### ID
```json
"xlOjM"
```
]
]

.column[
.plus[+]
]

.column[
.addition.codeBorder[
### Fragment
```graphql
fragment on Person {
  id
  height
  name
}
```
]
]

]
.big.flex[.equals[=]]
.big.flex[
.column[
.addition.codeBorder[
### Result

```json
{
  id: "xlOjM=",
  height: 96,
  name: "R2-D2",
}
```
]
]
]
???
* From this flattened store object, an ID reference, and the fragment, you could create a function that returns the correct data for a component.
* Only the correct fields will be returned even if additional data will be fetched. 
* This is what `createFragmentContainer` does internally.
* It's implemented by getting the selected fields from the AST of the graphql fragment, and a recursive function that can follow the references in the store.
* If you've used react-redux, it's a lot like the connect function, except here it can be buit automatically by the fragment data.
---
# Selecting data out of the store

.codeBorder[
### Implementation
```js
function createFragmentContainer(Component, fragments) {
  return function HOC(props) {
    let componentProps = {};
    for (const propName in fragments) {
      componentProps[prop] = selectDataFromStore(
        props[propName].id,
        fragments[propName]
      );
    }

    return <Component {...props} {...componentProps} />;
  };
}
```
]

.codeBorder.smallCode.marginTop[
### Usage
```js
// create HOC
export default createFragmentContainer(PersonComponent, {
  person: graphql`
    fragment PersonComponent_person on Person {
      id
      height
    }
  `
});

// render HOC
<PersonComponent person={props.person} />
```
]

???
* At the top of this slide is a very simple implementation of createFragmentContainer
* * For each fragment passed to `createFragmentContainer` we check for a prop with the same name passed in and select the correct data out of the store.
* * The selected data is passed to the component, overriding the props from the parent.
* At the bottom is how a fragment container is defined
* Then how its used in the consuming component

---
# Why data masking?
* Why is this good? It prevents implicit data dependencies
* If this field is no longer used in this component you can have complete confidence that it can be removed from the query without understanding the whole codebase.
* Helps you ensure you are not over fetching.
* Especially useful when you have a team working on the same codebase.

???
* I think this is an underrated feature of Relay

---
# That's all

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // highlightLanguage: 'javascript',
        highlightStyle: 'xcode'
      });
    </script>
  </body>
</html>
  